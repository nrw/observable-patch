{
  "author": {
    "name": "Dominic Tarr",
    "email": "dominic.tarr@gmail.com",
    "url": "dominictarr.com"
  },
  "name": "adiff",
  "description": "diff and patch arrays.",
  "version": "0.2.12",
  "homepage": "https://github.com/dominictarr/adiff",
  "repository": {
    "type": "git",
    "url": "git://github.com/dominictarr/adiff.git"
  },
  "main": "./index.js",
  "scripts": {
    "test": "set -e; for t in test/*.js; do node $t; done"
  },
  "devDependencies": {
    "tape": "~2.3.0",
    "es5-shim": "~2.1.0"
  },
  "optionalDependencies": {},
  "testling": {
    "files": "test/*.js",
    "browsers": [
      "ie/8..latest",
      "firefox/17..latest",
      "firefox/nightly",
      "chrome/22..latest",
      "chrome/canary",
      "opera/12..latest",
      "opera/next",
      "safari/5.1..latest",
      "ipad/6.0..latest",
      "iphone/6.0..latest",
      "android-browser/4.2..latest"
    ]
  },
  "readme": "# adiff - Array diff tools is javacript\n\nadiff is a minimal implementation of diff tools, diff, patch, diff3 in javascript.\n\n[![testling badge](https://ci.testling.com/dominictarr/adiff.png)](https://ci.testling.com/dominictarr/adiff)\n\n[![build status](https://secure.travis-ci.org/dominictarr/adiff.png)](http://travis-ci.org/dominictarr/adiff)\n\nI initially started writing this to understand how git works. then i got totally carried away.\nadiff is a central component in [snob](http://github.com/dominictarr/snob) a self hosting port of git to javascript.\n\n## how git works.\n\nif you want to know what is the difference between two files, you must first know what is the same.\nthis is called the Longest Common Subsequence problem. if you have two sequences `x = \"ABDCEF\" and `y = \"ABCXYZF\"` then `LCS(x,y)` is clearly \"ABCF\".\n\n## lcs\n\n```\nfunction lcs (a,b)\n  if head(a) == head(b)\n    then lcs(a,b) = head(a) + lcs(tail(a), tail(b))\n  else lcs(a, b) = max(lcs(tail(a),b), lcs(a, tail(b)))\n```\n\n(where max returns the longer list, head return the first element, and tail returns the rest of the sequence minus the head)\n\nthis is very simple, but with exponential time complexity.\nhowever, it can easily be made sufficantly performant by cacheing the return value of each call to lcs().\n\nsee js implementation, [index.js#L64-94](https://github.com/dominictarr/adiff/blob/master/index.js#L63-94)\n\n## chunking\n\nnow, we can see when the strings differ, by comparing them to the lcs. the next step is dividing them into 'stable' chunks where they match the lcs, and unstable chunks where they differ.\n\nbasically, to go from `chunk(\"ABDCEF\", \"ABCXYZF\")` to \n`[\"AB\", [\"D\", \"\"], \"C\", [\"E\", \"XYZ\"], \"F\"]`\n\nnote that stable and unstable chunks always alternate.\n\nbasically, you iterate over the sequences and while the heads match the head of the lcs, shift that value to a stable chunk.\nthen, while the heads do not match the next head of the lcs,\ncollect add those items into an unstable chunk.\n\n## diff\n\nonce you have the chunks getting a list of changes that you can apply is easy...\n\nmaking a diff from a to b we want to know what changes to make to a to get b. \nthe way I have node this [Array#splice](https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/splice)\nso, for `[\"AB\", [\"D\", \"\"], \"C\", [\"E\", \"XYZ\"], \"F\"]`we want:\n\n``` js\n  var changes = [\n    [4, 1, 'X', 'Y', 'Z'], //delete 1 item (\"E\") at index 4, then insert \"X\", \"Y\", \"Z\"\n    [2, 1] //delete 1 item at index 2 (\"D\")\n  ]\n``` \n\nnote, you can apply changes to the end of the array without altering the indexes in the start of the array.\n\nthis makes the function to apply the patch _very_ simple\n\n## patch\n\n``` js\n  function patch (orig, changes) {\n    var ary = orig.split('') //assuming that orig is just a string\n    changes.forEach(function (ch) {\n      [].splice.apply(ary, ch)\n    })\n    return ary.join('')\n  }\n```\n\n## diff3\n \nif we want a _distributed_ version management system, the we need to be able to make changes in parallel.\nthis is only a slightly more complicated problem. given a string `\"ABDCEF\"`, If I changed it to `\"ABCXYZF\"`\nand meanwhile you changed it to \"AXBCEFG\". we must compare each of our changes to the original string, the [Concestor](http://en.wikipedia.org/wiki/Concestor)\n\n## merging rules\n\nTODO: worked example with chunks, resolve.\n\n## license\n\nMIT / Apache2\n",
  "readmeFilename": "readme.markdown",
  "bugs": {
    "url": "https://github.com/dominictarr/adiff/issues"
  },
  "dependencies": {},
  "_id": "adiff@0.2.12",
  "dist": {
    "shasum": "248e426317f4a3a28726e31a82129392b70b1c30",
    "tarball": "http://registry.npmjs.org/adiff/-/adiff-0.2.12.tgz"
  },
  "_from": "adiff@^0.2.12",
  "_npmVersion": "1.3.11",
  "_npmUser": {
    "name": "dominictarr",
    "email": "dominic.tarr@gmail.com"
  },
  "maintainers": [
    {
      "name": "dominictarr",
      "email": "dominic.tarr@gmail.com"
    }
  ],
  "directories": {},
  "_shasum": "248e426317f4a3a28726e31a82129392b70b1c30",
  "_resolved": "https://registry.npmjs.org/adiff/-/adiff-0.2.12.tgz"
}
